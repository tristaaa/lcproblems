# leetcode problems

[| Sum problems](https://github.com/tristaaa/lcproblems/blob/master/README.md#-sum-problems)<br>
&ensp;&ensp;[- Two Sum](https://github.com/tristaaa/lcproblems/blob/master/README.md#11-two-sum)<br>
&ensp;&ensp;&ensp;&ensp;[- two sum (basic)](https://github.com/tristaaa/lcproblems/blob/master/README.md#-two-sum-basic)<br>
&ensp;&ensp;&ensp;&ensp;[- two sum (input array sorted)](https://github.com/tristaaa/lcproblems/blob/master/README.md#-two-sum-input-array-sorted)<br>
&ensp;&ensp;&ensp;&ensp;[- two sum (design a data structure)](https://github.com/tristaaa/lcproblems/blob/master/README.md#-two-sum-design-a-data-structure)<br>
&ensp;&ensp;&ensp;&ensp;[- two sum (input is a binary search tree)](https://github.com/tristaaa/lcproblems/blob/master/README.md#-two-sum-input-is-a-binary-search-tree)<br>
&ensp;&ensp;[- Three Sum](https://github.com/tristaaa/lcproblems/blob/master/README.md#12-three-sum)<br>
&ensp;&ensp;&ensp;&ensp;[- three sum (basic)](https://github.com/tristaaa/lcproblems/blob/master/README.md#-three-sum-basic)<br>
&ensp;&ensp;&ensp;&ensp;[- three sum closest](https://github.com/tristaaa/lcproblems/blob/master/README.md#-three-sum-closest)<br>
&ensp;&ensp;&ensp;&ensp;[- three sum smaller](https://github.com/tristaaa/lcproblems/blob/master/README.md#-three-sum-smaller)<br>
&ensp;&ensp;[- Four Sum](https://github.com/tristaaa/lcproblems/blob/master/README.md#13-four-sum)<br>
&ensp;&ensp;&ensp;&ensp;[- four sum (basic)](https://github.com/tristaaa/lcproblems/blob/master/README.md#-four-sum-basic)<br>
&ensp;&ensp;&ensp;&ensp;[- four sum count](https://github.com/tristaaa/lcproblems/blob/master/README.md#-four-sum-count)<br>
[| Stack problems](https://github.com/tristaaa/lcproblems/blob/master/README.md#-stack-problems)<br>
&ensp;&ensp;[- Binary Search Tree Iterator lc173](https://github.com/tristaaa/lcproblems/blob/master/README.md#21-binary-search-tree-iterator-lc173)<br>
[| Add problems](https://github.com/tristaaa/lcproblems/blob/master/README.md#-add-problems)<br>
&ensp;&ensp;[- Add Two Numbers](https://github.com/tristaaa/lcproblems/blob/master/README.md#31-add-two-numbers)<br>
&ensp;&ensp;&ensp;&ensp;[- add two number (reversed linked list)](https://github.com/tristaaa/lcproblems/blob/master/README.md#-add-two-number-reversed-linked-list)<br>
&ensp;&ensp;&ensp;&ensp;[- add two number (not reversed linked list)](https://github.com/tristaaa/lcproblems/blob/master/README.md#-add-two-number-not-reversed-linked-list)<br>
&ensp;&ensp;&ensp;&ensp;[- add to array](https://github.com/tristaaa/lcproblems/blob/master/README.md#-add-to-array)<br>
&ensp;&ensp;&ensp;&ensp;[- add binary strings](https://github.com/tristaaa/lcproblems/blob/master/README.md#-add-binary-strings)<br>
&ensp;&ensp;&ensp;&ensp;[- add integer strings](https://github.com/tristaaa/lcproblems/blob/master/README.md#-add-integer-strings)<br>
&ensp;&ensp;&ensp;&ensp;[- add integer using bit manipulation](https://github.com/tristaaa/lcproblems/blob/master/READE.md#-add-integer-using-bit-manipulation)<br>
&ensp;&ensp;&ensp;&ensp;[- multiply integer strings](https://github.com/tristaaa/lcproblems/blob/master/README.md#--multiply-integer-strings)<br>
[| Substring problems](https://github.com/tristaaa/lcproblems/blob/master/README.md#-substring-problems)<br>
&ensp;&ensp;[- Repeated Substring](https://github.com/tristaaa/lcproblems/blob/master/README.md#41-repeated-substring)<br>
&ensp;&ensp;[- Longest Substring](https://github.com/tristaaa/lcproblems/blob/master/README.md#42-longest-substring)<br>
&ensp;&ensp;[- longest Duplicate Substring lc1044](https://github.com/tristaaa/lcproblems/blob/master/README.md#longest-duplicate-substring-lc1044)<br>
&ensp;&ensp;&ensp;&ensp;[- longest substring w/o repeating chars](https://github.com/tristaaa/lcproblems/blob/master/README.md#-longest-substring-wo-repeating-chars)<br>
&ensp;&ensp;&ensp;&ensp;[- longest palindromic substring](https://github.com/tristaaa/lcproblems/blob/master/README.md#-longest-palindromic-substring)<br>
&ensp;&ensp;&ensp;&ensp;[- longest substring w/ at least k repeating chars](https://github.com/tristaaa/lcproblems/blob/master/README.md#-longest-substring-w-at-least-k-repeating-chars)<br>
&ensp;&ensp;[- Count Binary Substrings](https://github.com/tristaaa/lcproblems/blob/master/README.md#43-count-binary-substrings)<br>
&ensp;&ensp;[- Unique Substrings in Wraparound String](https://github.com/tristaaa/lcproblems/blob/master/README.md#44-unique-substrings-in-wraparound-string)<br>
&ensp;&ensp;[- Binary String W/ Substrings Representing 1-N](https://github.com/tristaaa/lcproblems/blob/master/README.md#45-binary-string-w-substrings-representing-1-n)<br>
[| Palindrome problems](https://github.com/tristaaa/lcproblems/blob/master/README.md#-palindrome-problems)<br>
&ensp;&ensp;[- Valid Palindrome](https://github.com/tristaaa/lcproblems/blob/master/README.md#51-valid-palindrome)<br>
&ensp;&ensp;&ensp;&ensp;[- valid palindrome (basic)](https://github.com/tristaaa/lcproblems/blob/master/README.md#-valid-palindrome-basic)<br>
&ensp;&ensp;&ensp;&ensp;[- valid palindrome (can delete one char)](https://github.com/tristaaa/lcproblems/blob/master/README.md#-valid-palindrome-can-delete-one-char)<br>
&ensp;&ensp;[- Palindrome Number](https://github.com/tristaaa/lcproblems/blob/master/README.md#52-palindrome-number)<br>
&ensp;&ensp;[- Palindrome Linked List](https://github.com/tristaaa/lcproblems/blob/master/README.md#53-palindrome-linked-list)<br>
&ensp;&ensp;[- Longest Palindrome](https://github.com/tristaaa/lcproblems/blob/master/README.md#54-longest-palindrome)<br>
&ensp;&ensp;[- Prime Palindrome](https://github.com/tristaaa/lcproblems/blob/master/README.md#55-prime-palindrome)<br>
&ensp;&ensp;[- Palindrome Partition](https://github.com/tristaaa/lcproblems/blob/master/README.md#56-palindrome-partition)<br>
&ensp;&ensp;&ensp;&ensp;[- palindrome partition (basic)](https://github.com/tristaaa/lcproblems/blob/master/README.md#-palindrome-partition-basic)<br>
&ensp;&ensp;&ensp;&ensp;[- palindrome partition (min cut)](https://github.com/tristaaa/lcproblems/blob/master/README.md#-palindrome-partition-min-cut)<br>
&ensp;&ensp;[- Palindrome Permutation](https://github.com/tristaaa/lcproblems/blob/master/README.md#57-palindrome-permutation)<br>
&ensp;&ensp;&ensp;&ensp;[- palindrome permutation (basic)](https://github.com/tristaaa/lcproblems/blob/master/README.md#-palindrome-permutation-basic)<br>
&ensp;&ensp;&ensp;&ensp;[- palindrome permutation (list all possible ret)](https://github.com/tristaaa/lcproblems/blob/master/README.md#-palindrome-permutation-list-all-possible-ret)<br>
&ensp;&ensp;[- Palindromic Substrings](https://github.com/tristaaa/lcproblems/blob/master/README.md#58-palindromic-substrings)<br>
[| Subsequence problems](https://github.com/tristaaa/lcproblems/blob/master/README.md#-subsequence-problems)<br>
&ensp;&ensp;[- Longest Palindromic Subsequence](https://github.com/tristaaa/lcproblems/blob/master/README.md#61-longest-palindromic-subsequence)<br>
[| Uncategorized problems](https://github.com/tristaaa/lcproblems/blob/master/README.md#-uncategorized-problems)<br>
&ensp;&ensp;[- 1. Find Median Sorted Arrays lc4](https://github.com/tristaaa/lcproblems/blob/master/README.md#1-find-median-sorted-arrays-lc4)<br>
&ensp;&ensp;[- 2. Reverse Integer lc7](https://github.com/tristaaa/lcproblems/blob/master/README.md#2-reverse-integer-lc7)<br>
&ensp;&ensp;[- 3. String to Integer(atoi) lc8](https://github.com/tristaaa/lcproblems/blob/master/README.md#3-string-to-integeratoi-lc8)<br>
&ensp;&ensp;[- 4. Remove Elements lc27](https://github.com/tristaaa/lcproblems/blob/master/README.md#4-remove-elements-lc27)<br>
&ensp;&ensp;[- 5.1 Remove Duplicates from Sorted Array lc26](https://github.com/tristaaa/lcproblems/blob/master/README.md#51-remove-duplicates-from-sorted-array-lc26)<br>
&ensp;&ensp;[- 5.2 Remove Duplicates from Sorted Array II lc80](https://github.com/tristaaa/lcproblems/blob/master/README.md#52-remove-duplicates-from-sorted-array-ii-lc80)<br>
&ensp;&ensp;[- 6. Number of Dice Rolls With Target Sum lc1155](https://github.com/tristaaa/lcproblems/blob/master/README.md#6-number-of-dice-rolls-with-target-sum-lc1155)<br>
&ensp;&ensp;[- 7. Find the Celebrity lc277](https://github.com/tristaaa/lcproblems/blob/master/README.md#7-find-the-celebrity-lc277)<br>
&ensp;&ensp;[- 8. Rotate Array lc189](https://github.com/tristaaa/lcproblems/blob/master/README.md#8-rotate-array-lc189)<br>
&ensp;&ensp;[- 9. First Missing Positive lc41](https://github.com/tristaaa/lcproblems/blob/master/README.md#9-first-missing-positive-lc41)<br>
&ensp;&ensp;[- 10. Bulls and Cows lc299](https://github.com/tristaaa/lcproblems/blob/master/README.md#10-bulls-and-cows-lc299)<br>
&ensp;&ensp;[- 11. Gas Station lc134](https://github.com/tristaaa/lcproblems/blob/master/README.md#11-gas-station-lc134)<br>
&ensp;&ensp;[- 12.2 Pascal's Triangle lc118](https://github.com/tristaaa/lcproblems#121-pascals-triangle-lc118)<br>
&ensp;&ensp;[- 12.2 Pascal's Triangle II lc119](https://github.com/tristaaa/lcproblems#122-pascals-triangle-ii-lc119)<br>
&ensp;&ensp;[- 13. Binary Tree Preorder Traversal lc144](https://github.com/tristaaa/lcproblems#13-binary-tree-preorder-lc144)<br>
&ensp;&ensp;[- 14. Find Words That Can Be Formed By Characters lc1160](https://github.com/tristaaa/lcproblems#14-find-words-that-can-be-formed-by-characters-lc1160)<br>
&ensp;&ensp;[- 15. H-index lc274](https://github.com/tristaaa/lcproblems#15-h-index-lc274)<br>
&ensp;&ensp;[- 16.1 Shortest Word Distance lc243](https://github.com/tristaaa/lcproblems#161-shortest-word-distance-lc243)<br>
&ensp;&ensp;[- 16.2 Shortest Word Distance II lc244](https://github.com/tristaaa/lcproblems#162-shortest-word-distance-ii-lc244)<br>
&ensp;&ensp;[- 16.3 Shortest Word Distance III lc245](https://github.com/tristaaa/lcproblems#163-shortest-word-distance-iii-lc245)<br>
&ensp;&ensp;[- 17. Before and After Puzzle lc1181](https://github.com/tristaaa/lcproblems#17-before-and-after-puzzle-lc1181)<br>
&ensp;&ensp;[- 18.1 Contains Duplicate lc217](https://github.com/tristaaa/lcproblems#181-contains-duplicate-lc217)<br>
&ensp;&ensp;[- 18.2 Contains Duplicate II lc219](https://github.com/tristaaa/lcproblems#182-contains-duplicate-ii-lc219)<br>
&ensp;&ensp;[- 18.3 Contains Duplicate III lc220](https://github.com/tristaaa/lcproblems#183-contains-duplicate-iii-lc220)<br>
&ensp;&ensp;[- 19. Surrounded Regions lc130](https://github.com/tristaaa/lcproblems#19-surrounded-regions-lc130)<br>
&ensp;&ensp;[- 20.1 Kth Largest Element in a Stream lc703](https://github.com/tristaaa/lcproblems#201-kth-largest-element-in-a-stream-lc703)<br>
&ensp;&ensp;[- 20.2 Kth Largest Element in an Array lc215](https://github.com/tristaaa/lcproblems#202-kth-largest-element-in-an-array-lc215)<br>
&ensp;&ensp;[- 21. Third Maximum Number lc414](https://github.com/tristaaa/lcproblems#21-third-maximum-number-lc414)<br>
&ensp;&ensp;[- 22.1 Max Consecutive Ones lc485](https://github.com/tristaaa/lcproblems#221-max-consecutive-ones-lc485)<br>
&ensp;&ensp;[- 22.2 Max Consecutive Ones II lc487](https://github.com/tristaaa/lcproblems#222-max-consecutive-ones-ii-lc487)<br>
&ensp;&ensp;[- 23. Find All Anagrams in a String lc438](https://github.com/tristaaa/lcproblems#23-find-all-anagrams-in-a-string-lc438)<br>
&ensp;&ensp;[- 24.1 Minimum Window Substring lc76](https://github.com/tristaaa/lcproblems#241-minimum-window-substring-lc76)<br>
&ensp;&ensp;[- 24.2 Minimum Window Subsequence lc727](https://github.com/tristaaa/lcproblems#242-minimum-window-subsequence-lc727)<br>
&ensp;&ensp;[- 25.1 Sliding Window Maximum lc239](https://github.com/tristaaa/lcproblems#251-sliding-window-maximum-lc239)<br>
&ensp;&ensp;[- 25.2 Sliding Window Median lc480](https://github.com/tristaaa/lcproblems#252-sliding-window-median-lc480)<br>
&ensp;&ensp;[- 26.1 Min Stack lc155](https://github.com/tristaaa/lcproblems#261-min-stack-lc155)<br>
&ensp;&ensp;[- 26.2 Max Stack lc716](https://github.com/tristaaa/lcproblems#262-max-stack-lc716)<br>
&ensp;&ensp;[- 27. 01 Matrix lc542](https://github.com/tristaaa/lcproblems#27-01-matrix-lc542)<br>
&ensp;&ensp;[- 28. Shortest Bridge lc934](https://github.com/tristaaa/lcproblems#28-shortest-bridge-lc934)<br>
&ensp;&ensp;[- 29.1 The Maze lc490](https://github.com/tristaaa/lcproblems#291-the-maze-lc490)<br>
&ensp;&ensp;[- 29.2 The Maze II lc505](https://github.com/tristaaa/lcproblems#291-the-maze-ii-lc505)<br>
&ensp;&ensp;[- 29.3 The Maze III lc499](https://github.com/tristaaa/lcproblems#291-the-maze-iii-lc499)<br>
&ensp;&ensp;[- 30. Serialize and Deserialize Binary Tree lc297](https://github.com/tristaaa/lcproblems#30-serialize-and-deserialize-binary-tree-lc297)<br>

---


## | Sum problems
### 1.1 Two Sum
#### -two sum (basic)
 - Given an array of integers, return indices of the two numbers such that they add up to a specific target.
 - You may assume that each input would have exactly one solution, and you may not use the same element twice.
 - **Example:**
    ```python
    Given nums = [2, 7, 11, 15], target = 9,

    Because nums[0] + nums[1] = 2 + 7 = 9,
    return [0, 1].
    ```
 - [twosum](https://github.com/tristaaa/lcproblems/blob/master/twosum.py)

#### -two sum (input array sorted)
 - Given an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number.
 - The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2.
 - Note: 
  - Your returned answers (both index1 and index2) are not zero-based.
  - You may assume that each input would have exactly one solution and you may not use the same element twice.
 -  **Example:**
    ```python
    Input: numbers = [2,7,11,15], target = 9
    Output: [1,2]
    Explanation: The sum of 2 and 7 is 9. Therefore index1 = 1, index2 = 2.
    ```
 - [twosumII](https://github.com/tristaaa/lcproblems/blob/master/twosumii.py)

#### -two sum (design a data structure)
 - Design and implement a TwoSum class. It should support the following operations: `add` and `find`.
 - `add`: Add the number to an internal data structure.
 - `find`: Find if there exists any pair of numbers which sum is equal to the value.
 - **Example:**
    ```python
    add(1)
    add(3)
    add(5)
    find(4) # return True
    find(7) # return False
    ```
 - [twosumIII](https://github.com/tristaaa/lcproblems/blob/master/twosumiii.py)

#### -two sum (input is a binary search tree)
 - Given a Binary Search Tree and a target number, return true if there exist two elements in the BST such that their sum is equal to the given target.
 -  **Example:**
    ```python
    Input: 
        5
       / \
      3   6
     / \   \
    2   4   7

    Target = 9

    Output: True
    ```
 - [twosumIV](https://github.com/tristaaa/lcproblems/blob/master/twosumiv.py)


### 1.2 Three Sum
#### -three sum (basic)
 - Given an array nums of n integers, are there elements a, b, c in nums such that a + b + c = 0? 
 - Find all unique triplets in the array which gives the sum of zero.
 - Note: The solution set must not contain duplicate triplets.
 - **Example:**
    ```python
    Given array nums = [-1, 0, 1, 2, -1, -4],

    A solution set is:
    [
      [-1, 0, 1],
      [-1, -1, 2]
    ]
    ```
 - [3sum](https://github.com/tristaaa/lcproblems/blob/master/threesum.py)

#### -three sum closest
 - Given an array nums of n integers and an integer target, find three integers in nums such that the sum is closest to target. 
 - Return the sum of the three integers. You may assume that each input would have exactly one solution.
 - **Example:**
    ```python
    Given array nums = [-1, 2, 1, -4], and target = 1.

    The sum that is closest to the target is 2. (-1 + 2 + 1 = 2).
    ```
 - [3sumClosest](https://github.com/tristaaa/lcproblems/blob/master/threesumclosest.py)

#### -three sum smaller
 - Given an array of n integers `nums` and a target, find the number of index triplets `(i,j,k)` with `0<=i<j<k<n` that satisfy the condition: `nums[i]+nums[j]+nums[k] < target`.
 - **Example:**
    ```python
    Input: nums = [-2,0,1,3], and target = 2
    Output: 2
    Explanation: Because there are two triplets which sums are less than 2:
        [-2,0,1]
        [-2,0,3]
    ```
 - [3sumSmaller](https://github.com/tristaaa/lcproblems/blob/master/threesumsmaller.py)



### 1.3 Four Sum
#### -four sum (basic)
 - Given an array nums of n integers and an integer target, are there elements a, b, c, and d in nums such that a + b + c + d = target? 
 - Find all unique quadruplets in the array which gives the sum of target.
 - Note: The solution set must not contain duplicate quadruplets.
 - **Example:**
    ```python
    Given array nums = [1, 0, -1, 0, -2, 2], and target = 0.

    A solution set is:
    [
      [-1,  0, 0, 1],
      [-2, -1, 1, 2],
      [-2,  0, 0, 2]
    ]
    ```
 - [4sum](https://github.com/tristaaa/lcproblems/blob/master/foursum.py)
    - a general solution for all numbers of N sum using two pointers

#### -four sum count
 - Given four lists A, B, C, D of integer values, compute how many tuples (i, j, k, l) there are such that A[i] + B[j] + C[k] + D[l] is zero.
 - To make problem a bit easier, all A, B, C, D have same length of N where 0 ≤ N ≤ 500. All integers are in the range of -228 to 228 - 1 and the result is guaranteed to be at most 231 - 1.
 - **Example:**
    ```python
    Input:
    A = [ 1, 2]
    B = [-2,-1]
    C = [-1, 2]
    D = [ 0, 2]

    Output:
    2

    Explanation:
    The two tuples are:
    1. (0, 0, 0, 1) -> A[0] + B[0] + C[0] + D[1] = 1 + (-2) + (-1) + 2 = 0
    2. (1, 1, 0, 0) -> A[1] + B[1] + C[0] + D[0] = 2 + (-1) + (-1) + 0 = 0
    ```
 - [4sumCount](https://github.com/tristaaa/lcproblems/blob/master/foursumcount.py)



## | Stack problems
### 2.1 Binary Search Tree Iterator lc173
 - (link)[https://leetcode.com/problems/binary-search-tree-iterator]
 - medium
 - Implement an iterator over a binary search tree (BST). Your iterator will be initialized with the root node of a BST.
 - Calling `next()` will return the next smallest number in the BST.
 - Note: 
  - `next()` and `hasNext()` should run in average O(1) time and uses O(h) memory, where h is the height of the tree.
  - You may assume that `next()` call will always be valid, that is, there will be at least a next smallest number in the BST when `next()` is called.
 - **Example:**
    ```python
    Input: 
        7
       / \
      3   15
         /  \
        9   20

    BSTIterator iterator = new BSTIterator(root);
    iterator.next();    # return 3
    iterator.next();    # return 7
    iterator.hasNext(); # return True
    iterator.next();    # return 9
    iterator.hasNext(); # return True
    iterator.next();    # return 15
    iterator.hasNext(); # return True
    iterator.next();    # return 20
    iterator.hasNext(); # return False
    ```
 - [bstIterator](https://github.com/tristaaa/lcproblems/blob/master/bstiter.py)



## | Add problems
### 3.1 Add Two Numbers
#### -add two number (reversed linked list)
 - You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. 
 - Add the two numbers and return it as a linked list.
 - You may assume the two numbers do not contain any leading zero, except the number 0 itself.
 - **Example:**
    ```python
    Input: (2 -> 4 -> 3) + (5 -> 6 -> 4)
    Output: 7 -> 0 -> 8
    Explanation: 342 + 465 = 807.
    ```
 - [addTwoNumbers](https://github.com/tristaaa/lcproblems/blob/master/addtwonum.py)

#### -add two number (not reversed linked list)
 - You are given two non-empty linked lists representing two non-negative integers. The most significant digit comes first and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.
 - You may assume the two numbers do not contain any leading zero, except the number 0 itself.
 - Note: What if you cannot modify the input lists? In other words, reversing the lists is not allowed.
 - **Example:**
    ```python
    Input: (7 -> 2 -> 4 -> 3) + (5 -> 6 -> 4)
    Output: 7 -> 8 -> 0 -> 7
    ```
 - [addTwoNumbersII](https://github.com/tristaaa/lcproblems/blob/master/addtwonumii.py)

#### -add to array
 - For a non-negative integer `X`, the array-form of `X `is an array of its digits in left to right order.  For example, if `X` = 1231, then the array form is [1,2,3,1].
 - Given the array-form `A` of a non-negative integer `X`, return the array-form of the integer `X+K`.
 - Note: 
  - 1 <= A.length <= 10000
  - 0 <= A[i] <= 9
  - 0 <= K <= 10000
  - If A.length > 1, then A[0] != 0
 - **Example:**
    ```python
    Input: A = [1,2,0,0], K = 34
    Output: [1,2,3,4]
    Explanation: 1200 + 34 = 1234

    Input: A = [9,9,9,9,9,9,9,9,9,9], K = 1
    Output: [1,0,0,0,0,0,0,0,0,0,0]
    Explanation: 9999999999 + 1 = 10000000000
    ```
 - [addToArray-formOfInt](https://github.com/tristaaa/lcproblems/blob/master/add2arrayformofint.py)

#### -add binary strings
 - Given two binary strings, return their sum (also a binary string).
 - The input strings are both non-empty and contains only characters 1 or 0.
 - **Example:**
    ```python
    Input: a = "11", b = "1"
    Output: "100"

    Input: a = "1010", b = "1011"
    Output: "10101"
    ```
 - [addBinary](https://github.com/tristaaa/lcproblems/blob/master/addbinary.py)

#### -add integer strings
 - Given two non-negative integers `num1` and `num2` represented as string, return the sum of `num1` and `num2`.
 - Note: 
  - The length of both num1 and num2 is < 5100.
  - Both num1 and num2 contains only digits 0-9.
  - Both num1 and num2 does not contain any leading zero.
  - You must not use any built-in BigInteger library or convert the inputs to integer directly.
 - [addStrings](https://github.com/tristaaa/lcproblems/blob/master/addstrings.py)

#### -add integer using bit manipulation
 - Calculate the sum of two integers a and b, but you are not allowed to use the operator `+` and `-`.
 - **Example:**
    ```python
    Input: a = -2, b = 3
    Output: 1
    ```
 - [addTwoNumBitOps](https://github.com/tristaaa/lcproblems/blob/master/addtwonumBitOps.py)
  - Extension: [A summary: how to use bit manipulation to solve problems easily and efficiently](https://leetcode.com/problems/sum-of-two-integers/discuss/84278/A-summary%3A-how-to-use-bit-manipulation-to-solve-problems-easily-and-efficiently)

#### - ***multiply integer strings***
 - Given two non-negative integers num1 and num2 represented as strings, return the product of num1 and num2, also represented as a string.
 - **Example:**
    ```python
    Input: num1 = "123", num2 = "456"
    Output: "56088"
    ```
 - [multiplyNumbers](https://github.com/tristaaa/lcproblems/blob/master/multiplynum.py)


### 3.2 Add Digits
 - Given a non-negative integer num, repeatedly add all its digits until the result has only one digit.
 - Given a solution with O(1) running time.
 - **Example:**
    ```python
    Input: 38
    Output: 2 
    Explanation: The process is like: 3 + 8 = 11, 1 + 1 = 2. 
        Since 2 has only one digit, return it.
    ```
 - [addDigits](https://github.com/tristaaa/lcproblems/blob/master/adddigits.py)



## | Substring problems
### 4.1 Repeated Substring
 - Given a non-empty string check if it can be constructed by taking a substring of it and appending multiple copies of the substring together. 
 - You may assume the given string consists of lowercase English letters only and its length will not exceed 10000.
 - **Example:**
    ```python
    Input: "abab"
    Output: True
    Explanation: It's the substring "ab" twice.

    Input: "aba"
    Output: False
    ```
 - [repeatedSubstr](https://github.com/tristaaa/lcproblems/blob/master/isrepeatedsubstr.py) 


### 4.2 Longest Substring
#### -longest substring w/o repeating chars
 - (link)[https://leetcode.com/problems/longest-duplicate-substring/]
 - hard
 - Given a string `S`, consider all duplicated substrings: (contiguous) substrings of `S` that occur 2 or more times.  (The occurrences may overlap.)
 - Return **any** duplicated substring that has the longest possible length.  (If `S` does not have a duplicated substring, the answer is "".)
 - Note:
    - 2 <= `S.length` <= 10^5
    - `S` consists of lowercase English letters.
 - **Example:**
    ```python
    Input: "banana"
    Output: "ana"

    Input: "abcd"
    Output: ""
    ```
 - [longestDupSubstr](https://github.com/tristaaa/lcproblems/blob/master/ldupsubstr.py)

#### -longest substring w/o repeating chars
 - Given a string, find the length of the longest substring without repeating characters.
 - **Example:**
    ```python
    Input: "abcabcbb"
    Output: 3 
    Explanation: The answer is "abc", with the length of 3. 

    Input: "bbbbb"
    Output: 1
    Explanation: The answer is "b", with the length of 1.
    ```
 - [longestSubstrWORepeatingChars](https://github.com/tristaaa/lcproblems/blob/master/lssworeapeatingchars.py)

#### -longest palindromic substring 
 - Given a string s, find the longest palindromic substring in s. 
 - You may assume that the maximum length of s is 1000.
 - **Example:**
    ```python
    Input: "babad"
    Output: "bab"
    Note: "aba" is also a valid answer.

    Input: "cbbd"
    Output: "bb"
    ```
 - [longestPalindromicSubstr](https://github.com/tristaaa/lcproblems/blob/master/lsspalindromic.py)

#### -longest substring w/ at least k repeating chars
  - Find the length of the longest substring T of a given string (consists of lowercase letters only) such that every character in T appears no less than k times.
  - **Example:**
    ```python
    Input: s = "aaabb", k = 3
    Output: 3

    The longest substring is "aaa", as 'a' is repeated 3 times.

    Input: s = "ababbc", k = 2
    Output: 5

    The longest substring is "ababb", as 'a' is repeated 2 times and 'b' is repeated 3 times.
    ```
 - [longestSubstrWKRepeatingChars](https://github.com/tristaaa/lcproblems/blob/master/lsswkreapeatingchars.py)


### 4.3 Count Binary Substrings
 - Give a string s, count the number of non-empty (contiguous) substrings that have the same number of 0's and 1's, and all the 0's and all the 1's in these substrings are grouped consecutively.
 - Substrings that occur multiple times are counted the number of times they occur.
 - **Example:**
    ```python
    Input: "00110011"
    Output: 6
    Explanation: There are 6 substrings that have equal number of consecutive 1's and 0's: "0011", "01", "1100", "10", "0011", and "01".

    Notice that some of these substrings repeat and are counted the number of times they occur.

    Also, "00110011" is not a valid substring because all the 0's (and 1's) are not grouped together.
    ```
 - [cntBinarySubstr](https://github.com/tristaaa/lcproblems/blob/master/cntbinarysubstr.py)


### 4.4 Unique Substrings in Wraparound String
 - Consider the string `s` to be the infinite wraparound string of "abcdefghijklmnopqrstuvwxyz", so `s` will look like this: "...zabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcd....".
 - Now we have another string `p`. 
 - Your job is to find out how many unique non-empty substrings of `p` are present in `s`. 
 - In particular, your input is the string `p` and you need to output the number of different non-empty substrings of `p` in the string `s`.
 - Note: `p` consists of only lowercase English letters and the size of p might be over 10000.
 - **Example:**
    ```python
    Input: "a"
    Output: 1
    Explanation: Only the substring "a" of string "a" is in the string `s`.

    Input: "cac"
    Output: 2
    Explanation: There are two substrings "a", "c" of string "cac" in the string `s`.

    Input: "zab"
    Output: 6
    Explanation: There are six substrings "z", "a", "b", "za", "ab", "zab" of string "zab" in the string `s`.
    ```
 - [unqSubstrInWraparoundStr](https://github.com/tristaaa/lcproblems/blob/master/unqsubstrinwraparoundstr.py)


### 4.5 Binary String W/ Substrings Representing 1-N
 - Given a binary string S (a string consisting only of '0' and '1's) and a positive integer N, return true if and only if for every integer X from 1 to N, the binary representation of X is a substring of S.
 - Note:
  - 1 <= len(S) <= 1000
  - 1 <= N <= 10^9
 - **Example:**
    ```python
    Input: S = "0110", N = 3
    Output: true

    Input: S = "0110", N = 4
    Output: false
    ```
 - [binWSubstrRep1toN](https://github.com/tristaaa/lcproblems/blob/master/binwsubstrrep1ton.py)


 



## | Palindrome problems
### 5.1 Valid Palindrome 
#### -valid palindrome (basic) 
 - Given a string, determine if it is a palindrome, considering only alphanumeric characters and ignoring cases.
 - Note: For the purpose of this problem, we define empty string as valid palindrome.
 - **Example:**
    ```python
    Input: "A man, a plan, a canal: Panama"
    Output: true
    ```
 - [validPalindrome](https://github.com/tristaaa/lcproblems/blob/master/palindromevalid.py)

#### -valid palindrome (can delete one char)
 - Given a non-empty string s, you may delete at most one character. 
 - Judge whether you can make it a palindrome.
 - Note: 
  - The string will only contain lowercase characters a-z. 
  - The maximum length of the string is 50000.
 - **Example:**
    ```python
    Input: "aba"
    Output: True

    Input: "abca"
    Output: True
    Explanation: You could delete the character 'c'.
    ```
 - [validPalindromeII](https://github.com/tristaaa/lcproblems/blob/master/palindromevalidii.py)


### 5.2 Palindrome Number
 - Determine whether an integer is a palindrome. An integer is a palindrome when it reads the same backward as forward.
- **Example:**
    ```python
    Input: 121
    Output: true

    Input: -121
    Output: false
    Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome.
    ```
 - [palindromeNumber](https://github.com/tristaaa/lcproblems/blob/master/palindromenum.py)


### 5.3 Palindrome Linked List
 - Given a singly linked list, determine if it is a palindrome.
 - **Example:**
    ```python
    Input: 1->2->2->1
    Output: True
    ```
 - [palindromell](https://github.com/tristaaa/lcproblems/blob/master/palindromell.py)


### 5.4 Longest Palindrome
 - Given a string which consists of lowercase or uppercase letters, find the length of the longest palindromes that can be built with those letters.
 - This is case sensitive, for example "Aa" is not considered a palindrome here.
 - Note: Assume the length of given string will not exceed 1,010.
 - **Example:**
    ```python
    Input: "abccccdd"

    Output: 7

    Explanation:
    One longest palindrome that can be built is "dccaccd", whose length is 7.
    ```
 - [longestPalindrome](https://github.com/tristaaa/lcproblems/blob/master/palindromelongest.py)


### 5.5 Prime Palindrome
 - Find the smallest prime palindrome greater than or equal to N.
 - Recall that a number is prime if it's only divisors are 1 and itself, and it is greater than 1. 
 - For example, 2,3,5,7,11 and 13 are primes.
 - Recall that a number is a palindrome if it reads the same from left to right as it does from right to left. 
 - For example, 12321 is a palindrome.
 - Note:
  - 1 <= N <= 10^8
  - The answer is guaranteed to exist and be less than 2 * 10^8.
 - **Example:**
    ```python
    Input: 6
    Output: 7

    Input: 8
    Output: 11

    Input: 13
    Output: 101
    ```
 - [primePalindrome](https://github.com/tristaaa/lcproblems/blob/master/palindromeprime.py)


### 5.6 Palindrome Partition
#### -palindrome partition (basic)
 - Given a string s, partition s such that every substring of the partition is a palindrome.
 - Return all possible palindrome partitioning of s.
 - **Example:**
    ```python
    Input: "aab"
    Output:
    [
      ["aa","b"],
      ["a","a","b"]
    ]
    ```
 - [palindromePartition](https://github.com/tristaaa/lcproblems/blob/master/palindromepartition.py)

#### -palindrome partition (min cut)
 - Given a string s, partition s such that every substring of the partition is a palindrome.
 - Return the minimum cuts needed for a palindrome partitioning of s.
 - **Example:**
    ```python
    Input: "aab"
    Output:
    [
      ["aa","b"],
      ["a","a","b"]
    ]
    ```
 - [palindromePartitionII](https://github.com/tristaaa/lcproblems/blob/master/palindromepartitionii.py)


### 5.7 Palindrome Permutation
#### -palindrome permutation (basic)
 - Given a string s, determine if a permutation of the string could form a palindrome.
 - **Example:**
    ```python
    Input: "aabb"
    Output: True

    Input: "abc"
    Output: False
    ```
 - [palindromePermutation](https://github.com/tristaaa/lcproblems/blob/master/palindromepermutation.py)

#### -palindrome permutation (list all possible ret)
 - Given a string s, return all the palindromic permutations (without duplicates) of it. 
 - Return an empty list if no palindromic permutation could be form.
 - Hint:
  - If a palindromic permutation exists, we just need to generate the first half of the string.
  - To generate all distinct permutations of a (half of) string, use a similar approach from: `Permutations II` or `Next Permutation`.
 - **Example:**
    ```python
    Input: "aabb"
    Output: ["abba","baab"]

    Input: "abc"
    Output: []
    ```
 - [palindromePermutationII](https://github.com/tristaaa/lcproblems/blob/master/palindromepermutationii.py)
  - Extension:[permutationII](https://github.com/tristaaa/lcproblems/blob/master/permutationii.py)


### 5.8 Palindromic Substrings
 - Given a string, count how many palindromic substrings in this string.
 - The substrings with different start indexes or end indexes are counted as different substrings even they consist of same characters.
 - Note: The input string length won't exceed 1000.
 - **Example:**
    ```python
    Input: "abc"
    Output: 3
    Explanation: Three palindromic strings: "a", "b", "c".

    Input: "aaa"
    Output: 6
    Explanation: Six palindromic strings: "a", "a", "a", "aa", "aa", "aaa".
    ```
 - [palindromicSubstr](https://github.com/tristaaa/lcproblems/blob/master/palindromicsubstr.py)



## | Subsequence problems
### 6.1 Longest Palindromic Subsequence
 - Given a string s, find the longest palindromic subsequence's length in s. 
 - You may assume that the maximum length of s is 1000.
 - **Example:**
    ```python
    Input: "bbbab"
    Output: 4
    Explanation: The possible longest palindromic subsequence is "bbbb".

    Input: "cbbd"
    Output: 2
    Explanation: The possible longest palindromic subsequence is "bb".
    ```
 - [longestPalindromicSubseq](https://github.com/tristaaa/lcproblems/blob/master/lsseqpalindromic.py)


## | Uncategorized problems
### 1. Median of Two Sorted Arrays lc4
 - [link](https://leetcode.com/problems/median-of-two-sorted-arrays/)
 - hard
 - [medianSortedArr](https://github.com/tristaaa/lcproblems/blob/master/mediansortedarr.py)

### 2. Reverse Integer lc7
 - [link](https://leetcode.com/problems/reverse-integer/)
 - easy
 - [reverseInt](https://github.com/tristaaa/lcproblems/blob/master/reverseint.py)

### 3. String to Integer(atoi) lc8
 - [link](https://leetcode.com/problems/string-to-integer-atoi/)
 - mediun
 - [str2int(atoi)](https://github.com/tristaaa/lcproblems/blob/master/str2int_atoi.py)

### 4. Remove Elements lc27
 - [link](https://leetcode.com/problems/remove-element/)
 - easy
 - [removeelement](https://github.com/tristaaa/lcproblems/blob/master/removeelement.py)

### 5.1 Remove Duplicates from Sorted Array lc26
 - [link](https://leetcode.com/problems/remove-duplicates-from-sorted-array)
 - easy
 - [removeduplicates](https://github.com/tristaaa/lcproblems/blob/master/removedup.py)

### 5.2 Remove Duplicates from Sorted Array II lc80
 - [link](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii)
 - mediun
 - [removeduplicatesii](https://github.com/tristaaa/lcproblems/blob/master/removedupii.py)

### 6. Number of Dice Rolls With Target Sum lc1155
 - [link](https://leetcode.com/problems/number-of-dice-rolls-with-target-sum)
 - medium
 - [dicerollswtargetsum](https://github.com/tristaaa/lcproblems/blob/master/dicerollswtargetsum.py)

### 7. Find the Celebrity lc277
 - [link](https://leetcode.com/problems/find-the-celebrity)
 - medium
 - Suppose you are at a party with n people (labeled from 0 to n - 1) and among them, there may exist one celebrity. The definition of a celebrity is that all the other n - 1 people know him/her but he/she does not know any of them.
 - Now you want to find out who the celebrity is or verify that there is not one. The only thing you are allowed to do is to ask questions like: "Hi, A. Do you know B?" to get information of whether A knows B. You need to find out the celebrity (or verify there is not one) by asking as few questions as possible (in the asymptotic sense).
 - You are given a helper function `bool knows(a, b)` which tells you whether A knows B. Implement a function `int findCelebrity(n)`. There will be exactly one celebrity if he/she is in the party. 
 - Return the celebrity's label if there is a celebrity in the party. If there is no celebrity, return -1.
 - Note:
    - The directed graph is represented as an adjacency matrix, which is an n x n matrix where a[i][j] = 1 means person i knows person j while a[i][j] = 0 means the contrary.
    - Remember that you won't have direct access to the adjacency matrix.
 - **Example:**
    ```python
    Input: graph = [
      [1,1,0],
      [0,1,0],
      [1,1,1]
    ]
    Output: 1
    Explanation: There are three persons labeled with 0, 1 and 2. graph[i][j] = 1 means person i knows person j, otherwise graph[i][j] = 0 means person i does not know person j. The celebrity is the person labeled as 1 because both 0 and 2 know him but 1 does not know anybody.
    ```
 - [findcelebrity](https://github.com/tristaaa/lcproblems/blob/master/findcelebrity.py)

### 8. Rotate Array lc189
 - [link](https://leetcode.com/problems/rotate-array)
 - easy
 - Given an array, rotate the array to the right by k steps, where k is non-negative.
 - [rotatearr](https://github.com/tristaaa/lcproblems/blob/master/rotatearr.py)

### 9. First Missing Positive lc41
 - [link](https://leetcode.com/problems/first-missing-positive)
 - hard
 - Given an unsorted integer array, find the smallest missing positive integer.
 - Note: Your algorithm should run in O(n) time and uses constant extra space.
 - **Example:**
    ```python
    Input: [3,4,-1,1]
    Output: 2
    
    Input: [7,8,9,11,12]
    Output: 1
    ```
 - [fstmisspos](https://github.com/tristaaa/lcproblems/blob/master/fstmisspos.py)

### 10. Bulls and Cows lc299
 - [link](https://leetcode.com/problems/bulls-and-cows)
 - easy
 - You are playing the following Bulls and Cows game with your friend: 
    - You write down a number and ask your friend to guess what the number is. 
    - Each time your friend makes a guess, you provide a hint that indicates how many digits in said guess match your secret number exactly in both digit and position (called **"bulls"**) and how many digits match the secret number but locate in the wrong position (called **"cows"**). 
    - Your friend will use successive guesses and hints to eventually derive the secret number.
 - Write a function to return a hint according to the secret number and friend's guess, use `A` to indicate the bulls and `B` to indicate the cows. 
 - Note: 
    - both secret number and friend's guess may contain duplicate digits.
    - You may assume that the secret number and your friend's guess only contain digits, and their lengths are always equal.
 - **Example:**
    ```python
    Input: secret = "1807", guess = "7810"

    Output: "1A3B"

    Explanation: 1 bull and 3 cows. The bull is 8, the cows are 0, 1 and 7.

    Input: secret = "1123", guess = "0111"

    Output: "1A1B"

    Explanation: The 1st 1 in friend's guess is a bull, the 2nd or 3rd 1 is a cow.
    ```
 - [bullandcow](https://github.com/tristaaa/lcproblems/blob/master/bullandcow.py)

### 11. Gas Station lc134
 - [link](https://leetcode.com/problems/gas-station)
 - median
 - There are N gas stations along a circular route, where the amount of gas at station i is gas[i].(i begins at 0)
 - You have a car with an unlimited gas tank and it costs cost[i] of gas to travel from station i to its next station (i+1). You begin the journey with an empty tank at one of the gas stations.
 - Return the starting gas station's index if you can travel around the circuit once in the clockwise direction, otherwise return -1.
 - Note: 
    - If there exists a solution, it is guaranteed to be unique
    - Both input arrays are non-empty and have the same length
    - Each element in the input arrays is a non-negative integer
 - **Example:**
    ```python
    Input: 
    gas  = [1,2,3,4,5]
    cost = [3,4,5,1,2]

    Output: 3

    Explanation:
    Start at station 3 (index 3) and fill up with 4 unit of gas. Your tank = 0 + 4 = 4
    Travel to station 4. Your tank = 4 - 1 + 5 = 8
    Travel to station 0. Your tank = 8 - 2 + 1 = 7
    Travel to station 1. Your tank = 7 - 3 + 2 = 6
    Travel to station 2. Your tank = 6 - 4 + 3 = 5
    Travel to station 3. The cost is 5. Your gas is just enough to travel back to station 3.
    Therefore, return 3 as the starting index.

    Input: 
    gas  = [2,3,4]
    cost = [3,4,3]

    Output: -1

    Explanation:
    You can't start at station 0 or 1, as there is not enough gas to travel to the next station.
    Let's start at station 2 and fill up with 4 unit of gas. Your tank = 0 + 4 = 4
    Travel to station 0. Your tank = 4 - 3 + 2 = 3
    Travel to station 1. Your tank = 3 - 3 + 3 = 3
    You cannot travel back to station 2, as it requires 4 unit of gas but you only have 3.
    Therefore, you can't travel around the circuit once no matter where you start.
    ```
 - [gasstation](https://github.com/tristaaa/lcproblems/blob/master/gasstation.py)

### 12.1 Pascal's Triangle lc118
 - [link](https://leetcode.com/problems/pascals-triangle)
 - easy
 - Given a non-negative integer `numRows`, generate the first `numRows` of Pascal's triangle.
 - In Pascal's triangle, each number is the sum of the two numbers directly above it.
 - - **Example:**
    ```python
    Input: 5
    Output:
    [
         [1],
        [1,1],
       [1,2,1],
      [1,3,3,1],
     [1,4,6,4,1]
    ]
    ```
 - [pascaltriangle](https://github.com/tristaaa/lcproblems/blob/master/pascaltriangle.py)

### 12.2 Pascal's Triangle II lc119
 - [link](https://leetcode.com/problems/pascals-triangle-ii)
 - easy
 - Given a non-negative index k where k ≤ 33, return the kth index row of the Pascal's triangle.
 - Note that the row index starts from 0.
 - Optimize the algorithm to use only O(k) extra space
 - In Pascal's triangle, each number is the sum of the two numbers directly above it.
 - - **Example:**
    ```python
    Input: 5
    Output:
    [
         [1],
        [1,1],
       [1,2,1],
      [1,3,3,1],
     [1,4,6,4,1]
    ]
    ```
 - [pascaltriangleii](https://github.com/tristaaa/lcproblems/blob/master/pascaltriangleii.py)


### 13. Binary Tree Preorder Traversal lc144
 - [link](https://leetcode.com/problems/binary-tree-preorder-traversal)
 - medium
 - Given a binary tree, return the preorder traversal of its nodes' values..
 - **Example:**
    ```python
    Input: [1,null,2,3]
       1
        \
         2
        /
       3

    Output: [1,2,3]
    ```
 - [preorderTraversal](https://github.com/tristaaa/lcproblems/blob/master/preordertraversal.py)


### 14. Find Words That Can Be Formed by Characters lc1160
 - [link](https://leetcode.com/problems/find-words-that-can-be-formed-by-characters)
 - easy
 - You are given an array of strings words and a string chars.
 - A string is good if it can be formed by characters from chars (each character can only be used once).
 - Return the sum of lengths of all good strings in words.
 - **Example:**
    ```python
    Input: words = ["cat","bt","hat","tree"], chars = "atach"
    Output: 6
    Explanation: 
    The strings that can be formed are "cat" and "hat" so the answer is 3 + 3 = 6.

    Input: words = ["hello","world","leetcode"], chars = "welldonehoneyr"
    Output: 10
    Explanation: 
    The strings that can be formed are "hello" and "world" so the answer is 5 + 5 = 10.
    ```
 - [goodstring](https://github.com/tristaaa/lcproblems/blob/master/goodstring.py)


### 15. H-index lc274
 - [link](https://leetcode.com/problems/h-index)
 - median
 - Given an array of citations (each citation is a non-negative integer) of a researcher, write a function to compute the researcher's h-index.
 - According to the definition of h-index on Wikipedia: "A scientist has index h if h of his/her N papers have at least h citations each, and the other N − h papers have no more than h citations each."
 - Note: If there are several possible values for h, the maximum one is taken as the h-index.
 - Hint: 
    - An easy approach is to sort the array first.
    - What are the possible values of h-index?
    - A faster approach is to use extra space.
 - **Example:**
    ```python
    Input: citations = [3,0,6,1,5]
    Output: 3 
    Explanation: [3,0,6,1,5] means the researcher has 5 papers in total and each of them had received 3, 0, 6, 1, 5 citations respectively. 
        Since the researcher has 3 papers with at least 3 citations each and the remaining two with no more than 3 citations each, her h-index is 3.
    ```
 - [hindex](https://github.com/tristaaa/lcproblems/blob/master/hindex.py)


### 16.1 Shortest Word Distance lc243
 - [link](https://leetcode.com/problems/shortest-word-distance)
 - Given a list of words and two words word1 and word2, return the shortest distance between these two words in the list.
 - **Example:**
    ```python
    Assume that words = ["practice", "makes", "perfect", "coding", "makes"].

    Given word1 = "coding", word2 = "practice", return 3.
    Given word1 = "makes", word2 = "coding", return 1.
    ```
 - Note: You may assume that word1 does not equal to word2, and word1 and word2 are both in the list.
 - [shortestWordDis](https://github.com/tristaaa/lcproblems/blob/master/shortestworddis.py)

### 16.2 Shortest Word Distance II lc244
 - [link](https://leetcode.com/problems/shortest-word-distance-ii)
 - This is a follow up of Shortest Word Distance(243). The only difference is now you are given the list of words and your method will be called repeatedly many times with different parameters. How would you optimize it?
 - Design a class which receives a list of words in the constructor, and implements a method that takes two words word1 and word2 and return the shortest distance between these two words in the list.
 - **Example:**
    ```python
    Assume that words = ["practice", "makes", "perfect", "coding", "makes"].

    Given word1 = "coding", word2 = "practice", return 3.
    Given word1 = "makes", word2 = "coding", return 1.
    ```
 - Note: You may assume that word1 does not equal to word2, and word1 and word2 are both in the list.
 - [shortestWordDisII](https://github.com/tristaaa/lcproblems/blob/master/shortestworddisii.py)

### 16.3 Shortest Word Distance III lc245
 - [link](https://leetcode.com/problems/shortest-word-distance-iii)
 - This is a follow up of Shortest Word Distance. The only difference is now word1 could be the same as word2.
 - Given a list of words and two words word1 and word2, return the shortest distance between these two words in the list.
 - Note: 
    - word1 and word2 may be the same and they represent two individual words in the list.
    - You may assume that word1 and word2 are both in the list.
 - **Example:**
    ```python
    Assume that words = ["practice", "makes", "perfect", "coding", "makes"].

    Given word1 = "makes", word2 = "coding", return 1.
    Given word1 = "makes", word2 = "makes", return 3.
    ```
 - [shortestWordDisIII](https://github.com/tristaaa/lcproblems/blob/master/shortestworddisiii.py)


### 17. Before and After Puzzle lc1181
 - [link](https://leetcode.com/problems/before-and-after-puzzle)
 - median
 - Given a list of `phrases`, generate a list of Before and After puzzles.
 - A phrase is a string that consists of lowercase English letters and spaces only.
 - No space appears in the start or the end of a phrase. There are no consecutive spaces in a phrase.
 - Before and After puzzles are phrases that are formed by merging two phrases where the **last word of the first phrase** is the same as the **first word of the second phrase**.
 - Return the Before and After puzzles that can be formed by every two phrases phrases[i] and phrases[j] where i != j. Note that the order of matching two phrases matters, we want to consider both orders.
 - You should return a list of **distinct** strings sorted **lexicographically**.
 - Constriants
    - 1 <= phrases.length <= 100
    - 1 <= phrases[i].length <= 100
 - **Example:**
    ```python
    Input: phrases = ["writing code","code rocks"]
    Output: ["writing code rocks"]

    Input: phrases = ["mission statement",
                  "a quick bite to eat",
                  "a chip off the old block",
                  "chocolate bar",
                  "mission impossible",
                  "a man on a mission",
                  "block party",
                  "eat my words",
                  "bar of soap"]
    Output: ["a chip off the old block party",
             "a man on a mission impossible",
             "a man on a mission statement",
             "a quick bite to eat my words",
             "chocolate bar of soap"]

    Input: phrases = ["a","b","a"]
    Output: ["a"]
    ```
 - [bef&aftPuzzle](https://github.com/tristaaa/lcproblems/blob/master/befandaftpuzzle.py)


### 18.1 Contains Duplicate lc217
 - [link](https://leetcode.com/problems/contains-duplicate)
 - Easy
 - Given an array of integers, find if the array contains any duplicates.
 - Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.
 - **Example:**
    ```python
    Input: [1,1,1,3,3,4,3,2,4,2]
    Output: True
    ```
 - [containDup](https://github.com/tristaaa/lcproblems/blob/master/containdup.py)


### 18.2 Contains Duplicate II lc219
 - [link](https://leetcode.com/problems/contains-duplicate-ii)
 - Easy
 - Given an array of integers and an integer k, find out whether there are two distinct indices i and j in the array such that nums[i] = nums[j] and the **absolute** difference between i and j is at most k.
 - **Example:**
    ```python
    Input: nums = [1,2,3,1], k = 3
    Output: True

    Input: nums = [1,2,3,1,2,3], k = 2
    Output: False
    ```
 - [containDupii](https://github.com/tristaaa/lcproblems/blob/master/containdupii.py)


### 18.3 Contains Duplicate III lc220
 - [link](https://leetcode.com/problems/contains-duplicate-iii)
 - Median
 - Given an array of integers, find out whether there are two distinct indices i and j in the array such that the absolute difference between nums[i] and nums[j] is at most t and the absolute difference between i and j is at most k.
 - **Example:**
    ```python
    Input: nums = [1,2,3,1], k = 3, t = 0
    Output: True

    Input: nums = [1,0,1,1], k = 1, t = 2
    Output: True

    Input: nums = [1,5,9,1,5,9], k = 2, t = 3
    Output: False
    ```
 - [containDupiii](https://github.com/tristaaa/lcproblems/blob/master/containdupiii.py)


### 19. Surrounded Regions lc130
 - [link](https://leetcode.com/problems/surrounded-regions)
 - medium
 - Given a 2D board containing 'X' and 'O' (the letter O), capture all regions surrounded by 'X'.
 - A region is captured by flipping all 'O's into 'X's in that surrounded region.
 - **Example:**
    ```python
    Input board:
    X X X X
    X O O X
    X X O X
    X O X X

    After running your function, the board should be:
    X X X X
    X X X X
    X X X X
    X O X X

    Explanation: Surrounded regions shouldn’t be on the border, which means that any 'O' on the border of the board are not flipped to 'X'. Any 'O' that is not on the border and it is not connected to an 'O' on the border will be flipped to 'X'. Two cells are connected if they are adjacent cells connected horizontally or vertically.
    ```
 - [surroundedregion](https://github.com/tristaaa/lcproblems/blob/master/surroundedregion.py)


### 20.1 Kth Largest Element in a Stream lc703
 - [link](https://leetcode.com/problems/kth-largest-element-in-a-stream)
 - easy
 - Design a class to find the kth largest element in a stream. Note that it is the kth largest element in the sorted order, not the kth distinct element.
 - Your KthLargest class will have a constructor which accepts an integer k and an integer array nums, which contains initial elements from the stream. For each call to the method KthLargest.add, return the element representing the kth largest element in the stream.
 - Note: You may assume that nums' length ≥ k-1 and k ≥ 1.
 - **Example:**
    ```python
    int k = 3;
    int[] arr = [4,5,8,2];
    KthLargest kthLargest = new KthLargest(3, arr);
    kthLargest.add(3);   // returns 4
    kthLargest.add(5);   // returns 5
    kthLargest.add(10);  // returns 5
    kthLargest.add(9);   // returns 8
    kthLargest.add(4);   // returns 8
    ```
 - [KthLargest]
    ```java
    class KthLargest {
        private int k;
        private Queue<Integer> q;

        public KthLargest(int k, int[] nums) {
            this.k = k;
            q = new PriorityQueue<Integer>();
            for (int i = 0; i < nums.length; i++) {
                add(nums[i]);
            }
        }
        
        public int add(int val) {
            if (q.size() < this.k)
                q.offer(val);
            else {
                int curr = q.poll();
                if (val>curr)
                    curr = val;
                q.offer(curr);
            }
            return q.peek();
        }
    }
    /**
     * Your KthLargest object will be instantiated and called as such:
     * KthLargest obj = new KthLargest(k, nums);
     * int param_1 = obj.add(val);
     */
    ```


### 20.2 Kth Largest Element in an Array lc215
 - [link](https://leetcode.com/problems/kth-largest-element-in-an-array)
 - medium
 - Find the kth largest element in an unsorted array. Note that it is the kth largest element in the sorted order, not the kth distinct element.
 - Note: You may assume k is always valid, 1 ≤ k ≤ array's length.
 - **Example:**
    ```python
    Input: [3,2,1,5,6,4] and k = 2
    Output: 5

    Input: [3,2,3,1,2,4,5,5,6] and k = 4
    Output: 4
    ```
 - [findKthLargest]
    ```java
    class Solution {
        public int findKthLargest(int[] nums, int k) {
            Queue<Integer> minHeap = new PriorityQueue<Integer>();
            // maintain a min-heap of size k, where the first element is the kth largest element in the array `nums`
            for (int num : nums){
                if (minHeap.size()<k){
                    minHeap.offer(num);
                }else if(minHeap.peek()<num){
                    minHeap.poll();
                    minHeap.offer(num);
                }
            }
            
            return minHeap.peek();
        }
    }
    ```

### 20.3 Top K Frequent Elemnets lc347
 - [link](https://leetcode.com/problems/top-k-frequent-elements/)
 - medium
 - Given a non-empty array of integers, return the k most frequent elements.
 - Note: 
    - You may assume k is always valid, 1 ≤ k ≤ number of unique elements.
    - Your algorithm's time complexity must be better than O(n log n), where n is the array's size.
 - **Example:**
    ```python
    Input: nums = [1,1,1,2,2,3], k = 2
    Output: [1,2]

    Input: nums = [1], k = 1
    Output: [1]
    ```
 - [topKFrequent]
    ```java
    class Solution {
        public List<Integer> topKFrequent(int[] nums, int k) {
            // using the minheap to store the top k frequent numnber, O(Nlogk)
            List<Integer>[] bucket = new ArrayList[nums.length+1];
            // first count the frequency of each unique int
            Map<Integer,Integer> freqMap = new HashMap<Integer,Integer>();
            for(int n:nums){
                freqMap.put(n, freqMap.getOrDefault(n, 0)+1);
            }
            
            // put the frequency into minheap, O(Nlogk)
            Queue<Map.Entry<Integer, Integer>> minheap = new PriorityQueue<Map.Entry<Integer,Integer>>((a,b)-> a.getValue()-b.getValue());
            for (Map.Entry<Integer, Integer> entry : freqMap.entrySet()) {
                minheap.offer(entry);
                if(minheap.size()>k)
                    minheap.poll();
            }
            
            List<Integer> ret = new ArrayList<Integer>();
            for (Map.Entry<Integer, Integer> entry : minheap) {
                ret.add(entry.getKey());
                // int old = ret.set(0, entry.getKey());
                // ret.set(ret.size()-1, old);
            }
            return ret;
        }
    }
    ```

### 21. Third Maximum Number lc414
 - [link](https://leetcode.com/problems/third-maximum-number)
 - easy
 - Given a non-empty array of integers, return the third maximum number in this array. If it does not exist, return the maximum number. The time complexity must be in O(n).
 - **Example:**
    ```python
    Input: [2, 2, 3, 1]
    Output: 1
    Explanation: Note that the third maximum here means the third maximum distinct number.
    Both numbers with value 2 are both considered as second maximum.

    Input: [1, 2]
    Output: 2
    Explanation: The third maximum does not exist, so the maximum (2) is returned instead.
    ```
 - [thirdMax] can use priority queue along with a hashset in java
    ```python
    def thirdMax(self, nums: List[int]) -> int:
        # find the thrid largest distinct number
        # nums = list(set(nums))
        max1,max2,max3 = float('-inf'),float('-inf'),float('-inf')
        
        for num in nums:
            if num>max1:
                max1,max2,max3 = num,max1,max2
            elif num>max2 and num<max1:
                max2,max3 = num,max2
            elif num>max3 and num<max2:
                max3=num
        
        if max3==float('-inf'):
            return max(max1,max2)
        else:
            return max3
    ```

### 22.1 Max Consecutive Ones lc485
 - [link](https://leetcode.com/problems/max-consecutive-ones)
 - easy
 - Given a binary array, find the maximum number of consecutive 1s in this array.
 - Note: 
    - The input array will only contain 0 and 1.
    - The length of input array is a positive integer and will not exceed 10,000
 - **Example:**
    ```python
    Input: [1,1,0,1,1,1]
    Output: 3
    Explanation: The first two digits or the last three digits are consecutive 1s.
        The maximum number of consecutive 1s is 3.
    ```
 - [maxConsecutive1] using pointers
    ```python
    def findMaxConsecutiveOnes(self, nums):
        n=len(nums)
        start=0 # the left pointer of the window
        p=0 # the pointer to go through the array
        maxWindowSize=0
        while (p<n):
            while(p<n and not nums[p]): p+=1
            start=p
            while(p<n and nums[p]): p+=1
            if (p-start)>maxWindowSize:
                maxWindowSize = p-start
        return maxWindowSize
    ```

### 22.2 Max Consecutive Ones II lc487
 - [link](https://leetcode.com/problems/max-consecutive-ones-ii)
 - medium
 - Given a binary array, find the maximum number of consecutive 1s in this array if you can flip at most one 0.
 - Note: 
    - The input array will only contain 0 and 1.
    - The length of input array is a positive integer and will not exceed 10,000
 - Follow up: What if the input numbers come in one by one as an infinite stream? In other words, you can't store all numbers coming from the stream as it's too large to hold in memory. Could you solve it efficiently?(solve it in one path)
 - **Example:**
    ```python
    Input: [1,0,1,1,0]
    Output: 4
    Explanation: Flip the first zero will get the the maximum number of consecutive 1s.
        After flipping, the maximum number of consecutive 1s is 4.
    ```
  - [maxConsecutive1-wFlip0] using pointers
```python
    def findMaxConsecutiveOnes(nums):
        n=len(nums)
        start=0
        p=0
        maxWindowSize=0
        flipcnt=1 # has one chance to flip the zero, in this problem, it is 1
        zerocnt=0 # the number of zero in the window
        while (p<n):
            if not nums[p]: zerocnt+=1
            # make sure that the window has at most `flipcnt` number of zeros
            while zerocnt>flipcnt:
                if not nums[start]:
                    zerocnt-=1
                start+=1
            p+=1
            if (p-start)>maxWindowSize:
                maxWindowSize = p-start
        return maxWindowSize
    ```

### 23. Find All Anagrams in a String lc438
 - [link](https://leetcode.com/problems/find-all-anagrams-in-a-string)
 - medium
 - Given a string s and a non-empty string p, find all the start indices of p's anagrams in s.
 - Anagram is a word that formed by rearranging the letters of another, note the anagram can be the same as the original word
 - Strings consists of lowercase English letters only and the length of both strings s and p will not be larger than 20,100.
 - The order of output does not matter.
 - **Example:**
    ```python
    Input: s: "abab" p: "ab"
    Output: [0, 1, 2]
    Explanation:
    The substring with start index = 0 is "ab", which is an anagram of "ab".
    The substring with start index = 1 is "ba", which is an anagram of "ab".
    The substring with start index = 2 is "ab", which is an anagram of "ab".
    ```
 - sliding window: [findAnagram](https://github.com/tristaaa/lcproblems/blob/master/findAnagram.py)


### 24.1 Minimum Window Substring lc76
 - [link](https://leetcode.com/problems/minimum-window-substring)
 - hard
 - Given a string S and a string T, find the minimum window in S which will contain all the characters in T in complexity O(n).
 - **Example:**
    ```python
    Input: S = "ADOBECODEBANC", T = "ABC"
    Output: "BANC"
    ```
 - sliding window: [minWindowSubstr](https://github.com/tristaaa/lcproblems/blob/master/minwinsubstr.py)


### 24.2 Minimum Window Subsequence lc727
 - [link](https://leetcode.com/problems/minimum-window-subsequence)
 - hard
 - Given strings S and T, find the minimum (contiguous) substring W of S, so that T is a subsequence of W.
 - If there is no such window in S that covers all characters in T, return the empty string "". If there are multiple such minimum-length windows, return the one with the **left-most** starting index.
 - Note:
    - All the strings in the input will only contain lowercase letters.
    - The length of S will be in the range [1, 20000].
    - The length of T will be in the range [1, 100].
 - **Example:**
    ```python
    Input: S = "abcdebdde", T = "bde"
    Output: "bcde"
    Explanation: 
    "bcde" is the answer because it occurs before "bdde" which has the same length.
    "deb" is not a smaller window because the elements of T in the window must occur in order.
    ```
 - sliding window: [minWindowSubseq](https://github.com/tristaaa/lcproblems/blob/master/minwinsubseq.py)
 

### 25.1 Sliding Window Maximum lc239
 - [link](https://leetcode.com/problems/sliding-window-maximum)
 - hard
 - Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. 
 - You can only see the k numbers in the window. 
 - Each time the sliding window moves right by one position. 
 - Return the max sliding window.(the list of the local max value in every window)
 - Note: You may assume k is always valid, 1 ≤ k ≤ input array's size for non-empty array.
 - **Example:**
    ```python
    Input: nums = [1,3,-1,-3,5,3,6,7], and k = 3
    Output: [3,3,5,5,6,7] 
    Explanation: 
    Window position                Max
    ---------------               -----
    [1  3  -1] -3  5  3  6  7       3
     1 [3  -1  -3] 5  3  6  7       3
     1  3 [-1  -3  5] 3  6  7       5
     1  3  -1 [-3  5  3] 6  7       5
     1  3  -1  -3 [5  3  6] 7       6
     1  3  -1  -3  5 [3  6  7]      7
    ```
 - dequeue(double-ended queue): [slidingWinMaximum](https://github.com/tristaaa/lcproblems/blob/master/slidingwinmax.py)
 

### 25.2 Sliding Window Median lc480
 - [link](https://leetcode.com/problems/sliding-window-median)
 - hard
 - Median is the middle value in an ordered integer list. If the size of the list is even, there is no middle value. So the median is the mean of the two middle value.
 - Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. 
 - You can only see the k numbers in the window.
 - Each time the sliding window moves right by one position. 
 - Your job is to output the median array for each window in the original array.
 - Note: You may assume k is always valid, ie: k is always smaller than input array's size for non-empty array.
 - **Example:**
    ```python
    Given nums = [1,3,-1,-3,5,3,6,7], and k = 3.

    Window position                Median
    ---------------               -----
    [1  3  -1] -3  5  3  6  7       1
     1 [3  -1  -3] 5  3  6  7       -1
     1  3 [-1  -3  5] 3  6  7       -1
     1  3  -1 [-3  5  3] 6  7       3
     1  3  -1  -3 [5  3  6] 7       5
     1  3  -1  -3  5 [3  6  7]      6
    ```
 - dequeue(double-ended queue): [slidingWinMedian](https://github.com/tristaaa/lcproblems/blob/master/slidingwinmed.py)
 ```java
    // using two treesets to store the index
    public double[] medianSlidingWindow(int[] nums, int k) {
        int m = nums.length - k + 1;
        if (m<=0) return new double[0];

        //first sort in incresing value, then sort in increasing index
        Comparator<Integer> comparator = (a, b) -> nums[a] != nums[b] ? Integer.compare(nums[a], nums[b]) : a - b;
        // like maxheap, the first element is the largest, store indices where numbers are smaller than median
        TreeSet<Integer> left = new TreeSet<>(comparator.reversed());
        // like minheap, the first element is the smallest, store indices where numbers are larger than or equal to median
        TreeSet<Integer> right = new TreeSet<>(comparator);

        Supplier<Double> median = (k % 2) ?
            () -> (double) nums[right.first()]:
            () -> ((double) nums[left.first()] + nums[right.first()]) / 2 ;

        // balance lefts size and rights size (if not equal then right will be larger by one)
        Runnable balance = () -> { while (left.size() > right.size()) right.add(left.pollFirst()); };

        double[] result = new double[m];

        for (int i = 0; i < k; i++) 
            left.add(i);
        balance.run(); 
        result[0] = median.get();

        for (int i = k, r = 1; i < nums.length; i++, r++) {
            // remove tail of window from either left or right
            if(!left.remove(i - k)) 
                right.remove(i - k);

            // add next num, this will always increase left size
            right.add(i); 
            left.add(right.pollFirst());
            
            // rebalance left and right, then get median from them
            balance.run(); 
            result[r] = median.get();
        }

        return result;
    }
 ```


### 26.1 Min Stack lc155
 - [link](https://leetcode.com/problems/min-stack)
 - easy
 - Design a stack that supports push, pop, top, and retrieving the minimum element in constant time.
    push(x) -- Push element x onto stack.
    pop() -- Removes the element on top of the stack.
    top() -- Get the top element.
    getMin() -- Retrieve the minimum element in the stack.
 - **Example:**
    ```python
    minStack = MinStack();
    minStack.push(-2);
    minStack.push(0);
    minStack.push(-3);
    minStack.getMin();   --> Returns -3.
    minStack.pop();
    minStack.top();      --> Returns 0.
    minStack.getMin();   --> Returns -2.
    ```
 - build another stack for the curr minval: [minstack](https://github.com/tristaaa/lcproblems/blob/master/minstack.py)

### 26.2 Max Stack lc716
 - [link](https://leetcode.com/problems/max-stack)
 - easy
 - Design a max stack that supports push, pop, top, peekMax and popMax.
    push(x) -- Push element x onto stack.
    pop() -- Remove the element on top of the stack and return it.
    top() -- Get the element on the top.
    peekMax() -- Retrieve the maximum element in the stack.
    popMax() -- Retrieve the maximum element in the stack, and remove it. If you find more than one maximum elements, only remove the top-most one.
 - **Example:**
    ```python
    stack = MaxStack();
    stack.push(5); 
    stack.push(1);
    stack.push(5);
    stack.top(); -> 5
    stack.popMax(); -> 5
    stack.top(); -> 1
    stack.peekMax(); -> 5
    stack.pop(); -> 1
    stack.top(); -> 5
    ```
 - two stacks or double linked list+treemap: [maxstack](https://github.com/tristaaa/lcproblems/blob/master/minstack.py)
 - double linked list+treemap 
 ```java
     class MaxStack {
        
        private static class ListNode {
            public ListNode prev, next;
            public int value;
            
            public ListNode(int val) {
                this.value = val;
            }
        }
        
        private final ListNode head;
        private final TreeMap<Integer, LinkedList<ListNode>> map = new TreeMap<>(); 

        /** initialize your data structure here. */
        public MaxStack() {
            head = new ListNode(0);
            head.next = head.prev = head;
        }
        
        //O(logN)
        public void push(int x) {
            ListNode node = new ListNode(x);
            node.next = head;
            node.prev = head.prev;
            head.prev.next = node;
            head.prev = node;
            //get in treemap is logn
            map.computeIfAbsent(x, k -> new LinkedList<>()).add(node);
        }
        
        // O(logN)
        public int pop() {
            ListNode tail = head.prev;
            
            deleteNode(tail);
            // since it's pop(), we are always sure that the last element in the map's value list will be the tail
            map.get(tail.value).removeLast();
            //get is logn
            if (map.get(tail.value).isEmpty()) {
                //remove is logn
                map.remove(tail.value);
            }
            return tail.value;
        }
        
        //O(1)
        public int top() {
            return head.prev.value;
        }
        
        //O(logN)
        public int peekMax() {
            return map.lastKey();
        }
        
        //O(logN)
        public int popMax() {
            int max = peekMax();
            ListNode node = map.get(max).removeLast();
            deleteNode(node);
            if (map.get(max).isEmpty()) {
                map.remove(max);
            }
            return max;
        }
        
        private void deleteNode(ListNode node) {
            node.prev.next = node.next;
            node.next.prev = node.prev;
        }
    }
 ```

### 27. 01 Matrix lc542
 - [link](https://leetcode.com/problems/01-matrix)
 - medium
 - Given a matrix consists of 0 and 1, find the distance of the nearest 0 for each cell.
 - The distance between two adjacent cells is 1.
 - Note:
    - The number of elements of the given matrix will not exceed 10,000.
    - There are at least one 0 in the given matrix.
    - The cells are adjacent in only four directions: up, down, left and right.
 - **Example:**
    ```python
    Input:
    [[0,0,0],
     [0,1,0],
     [1,1,1]]

    Output:
    [[0,0,0],
     [0,1,0],
     [1,2,1]]
    ```
 - bfs: [01Matrix](https://github.com/tristaaa/lcproblems/blob/master/01matrix.py)
 ```java
    public int[][] updateMatrix(int[][] matrix) {
        if (matrix.length==0 || matrix[0].length==0) return matrix;
        
        int M = matrix.length;
        int N = matrix[0].length;
        //using bfs
        Queue<int[]> q = new LinkedList<int[]>();
        for (int i=0;i<M;i++){
            for(int j=0;j<N;j++){
                if(matrix[i][j]==0)
                    q.offer(new int[]{i,j});
                else{
                    // the greatest distance wouldn't be larger than M+N-2
                    matrix[i][j]=M+N;
                }
            }
        }
        
        int[][] dirs = new int[][] {{1,0},{0,1},{-1,0},{0,-1}};
        while(!q.isEmpty()) {
            int[] cell = q.poll();
            for(int[] dir: dirs) {
                int x = cell[0]+dir[0];
                int y = cell[1]+dir[1];
                // see if the new cell is a valid position and the greatest distance to zero can be updated to a smaller one
                if(x>=0 && x<M && y>=0 && y<N && matrix[x][y]>matrix[cell[0]][cell[1]]+1) {
                    q.offer(new int[]{x,y});
                    matrix[x][y] = matrix[cell[0]][cell[1]]+1;
                }
            }
        }
        
        return matrix;
    }
 ```


### 28. Shortest Bridge lc934
 - [link](https://leetcode.com/problems/shortest-bridge)
 - medium
 - In a given 2D binary array A, there are two islands.  (An island is a 4-directionally connected group of 1s not connected to any other 1s.)
 - Now, we may change 0s to 1s so as to connect the two islands together to form 1 island.
 - Return the smallest number of 0s that must be flipped.  (It is guaranteed that the answer is at least 1.)
 - Note:
    - 1 <= A.length = A[0].length <= 100
    - A[i][j] == 0 or A[i][j] == 1
 - **Example:**
    ```python
    Input: 
    [[0,1,0],
    [0,0,0],
    [0,0,1]]
    Output: 2

    Input: 
    [[1,1,1,1,1],
    [1,0,0,0,1],
    [1,0,1,0,1],
    [1,0,0,0,1],
    [1,1,1,1,1]]
    Output: 1
    ```
 - dfs and bfs: [shortestBridge](https://github.com/tristaaa/lcproblems/blob/master/shtbridge.py)

### 29.1 The Maze lc490
 - [link](https://leetcode.com/problems/the-maze)
 - medium
 - There is a ball in a maze with empty spaces and walls. The ball can go through empty spaces by rolling up, down, left or right, but it ***won't stop rolling until hitting a wall***. When the ball stops, it could choose the next direction.
 - Given the ball's start position, the destination and the maze, determine whether the ball could stop at the destination.
 - The maze is represented by a binary 2D array. 1 means the wall and 0 means the empty space. You may assume that the borders of the maze are all walls. The start and destination coordinates are represented by row and column indexes.
 - Note:
    - There is only one ball and one destination in the maze.
    - Both the ball and the destination exist on an empty space, and they will not be at the same position initially.
    - The given maze does not contain border (like the red rectangle in the example pictures), but you could assume the border of the maze are all walls.
    - The maze contains at least 2 empty spaces, and both the width and height of the maze won't exceed 100.
 - - **Example:**
    ```python
    Input 1: a maze represented by a 2D array
    0 0 1 0 0
    0 0 0 0 0
    0 0 0 1 0
    1 1 0 1 1
    0 0 0 0 0
    Input 2: start coordinate (rowStart, colStart) = (0, 4)
    Input 3: destination coordinate (rowDest, colDest) = (4, 4)
    Output: true
    Explanation: One possible way is : left -> down -> left -> down -> right -> down -> right.

    Input 1: a maze represented by a 2D array
    0 0 1 0 0
    0 0 0 0 0
    0 0 0 1 0
    1 1 0 1 1
    0 0 0 0 0
    Input 2: start coordinate (rowStart, colStart) = (0, 4)
    Input 3: destination coordinate (rowDest, colDest) = (3, 2)
    Output: false
    Explanation: There is no way for the ball to stop at the destination
    ```
 - dfs or bfs: [maze](https://github.com/tristaaa/lcproblems/blob/master/maze.py)


### 29.1 The Maze II lc505
 - [link](https://leetcode.com/problems/the-maze-ii)
 - medium
 - There is a ball in a maze with empty spaces and walls. The ball can go through empty spaces by rolling up, down, left or right, but it ***won't stop rolling until hitting a wall***. When the ball stops, it could choose the next direction.
 - Given the ball's start position, the destination and the maze, determine whether the ball could stop at the destination.
 - The maze is represented by a binary 2D array. 1 means the wall and 0 means the empty space. You may assume that the borders of the maze are all walls. The start and destination coordinates are represented by row and column indexes.
 - Note:
    - There is only one ball and one destination in the maze.
    - Both the ball and the destination exist on an empty space, and they will not be at the same position initially.
    - The given maze does not contain border (like the red rectangle in the example pictures), but you could assume the border of the maze are all walls.
    - The maze contains at least 2 empty spaces, and both the width and height of the maze won't exceed 100.
 - - **Example:**
    ```python
    Input 1: a maze represented by a 2D array
        0 0 1 0 0
        0 0 0 0 0
        0 0 0 1 0
        1 1 0 1 1
        0 0 0 0 0
    Input 2: start coordinate (rowStart, colStart) = (0, 4)
    Input 3: destination coordinate (rowDest, colDest) = (4, 4)
    Output: true
    Explanation: One possible way is : left -> down -> left -> down -> right -> down -> right.

    Input 1: a maze represented by a 2D array
        0 0 1 0 0
        0 0 0 0 0
        0 0 0 1 0
        1 1 0 1 1
        0 0 0 0 0
    Input 2: start coordinate (rowStart, colStart) = (0, 4)
    Input 3: destination coordinate (rowDest, colDest) = (3, 2)
    Output: false
    Explanation: There is no way for the ball to stop at the destination
    ```
 - dfs or bfs: [maze2](https://github.com/tristaaa/lcproblems/blob/master/mazeii.py)
 

### 29.1 The Maze III lc499
 - [link](https://leetcode.com/problems/the-maze-iii)
 - hard
 - There is a ball in a maze with empty spaces and walls. The ball can go through empty spaces by rolling up (u), down (d), left (l) or right (r), but it won't stop rolling until hitting a wall. When the ball stops, it could choose the next direction. 
 - There is also a **hole** in this maze. The ball will drop into the hole if it rolls on to the hole.
 - Given the ball position, the hole position and the maze, find out how the ball could drop into the hole by moving the **shortest distance**. The distance is defined by the number of empty spaces traveled by the ball from the start position (excluded) to the hole (included). 
 - Output the **moving directions** by using 'u', 'd', 'l' and 'r'. Since there could be several different shortest ways, you should output the **lexicographically smallest** way. If the ball cannot reach the hole, output "impossible".
 - The maze is represented by a binary 2D array. 1 means the wall and 0 means the empty space. You may assume that the borders of the maze are all walls. The ball and the hole coordinates are represented by row and column indexes.
 - Note:
    - There is only one ball and one destination in the maze.
    - Both the ball and the destination exist on an empty space, and they will not be at the same position initially.
    - The given maze does not contain border (like the red rectangle in the example pictures), but you could assume the border of the maze are all walls.
    - The maze contains at least 2 empty spaces, and both the width and height of the maze won't exceed 100.
 - - **Example:**
    ```python
    Input 1: a maze represented by a 2D array
        0 0 0 0 0
        1 1 0 0 1
        0 0 0 0 0
        0 1 0 0 1
        0 1 0 0 0
    Input 2: ball coordinate (rowStart, colStart) = (4, 3)
    Input 3: hole coordinate (rowDest, colDest) = (0, 1)
    Output: 'lul'
    Explanation: There are two shortest ways for the ball to drop into the hole.
    The first way is left -> up -> left, represented by "lul".
    The second way is up -> left, represented by 'ul'.
    Both ways have shortest distance 6, but the first way is lexicographically smaller because 'l' < 'u'. So the output is "lul".
    ```
 - dfs or bfs: [maze3](https://github.com/tristaaa/lcproblems/blob/master/mazeiii.py)
 ```java
    class Point implements Comparable<Point> {
        int row;
        int col;
        int dist;  // distance from ball
        String dir;  // directions from ball
        Point(int row, int col, int dist, String dir) {
            this.row = row;
            this.col = col;
            this.dist = dist;
            this.dir = dir;
        }
        public int compareTo(Point other) {
            return this.dist == other.dist ? this.dir.compareTo(other.dir) : this.dist - other.dist;
        }
    }
    public static String findShortestWay(int[][] maze, int[] ball, int[] hole) {
        PriorityQueue<Point> pq = new PriorityQueue<>();
        pq.offer(new Point(ball[0], ball[1], 0, ""));
        
        // arrays used for exploring 4 directions from a point
        // [1,0] means go down one row
        char[] dstr = {'d', 'l', 'r', 'u'};
        int[][] dirs = {{1,0},{0,-1},{0,1},{-1,0}};
        
        while (!pq.isEmpty()) {
            Point pt = pq.poll();
            // the current ball falls into the hole, 
            // since the first element in the priority queue must have the shortest distance to the start 
            // and the direction string is in the first in lexicographical order
            if (pt.row == hole[0] && pt.col == hole[1]) { 
                return pt.dir;
            }
            if(maze[pt.row][pt.col] == 2) continue;
            maze[pt.row][pt.col] = 2;
            
            for (int i = 0; i < dirs.length; i++) {
                int x = pt.row;
                int y = pt.col;
                int dist = pt.dist;
                String ds = pt.dir;
                
                // Explore current direction until hitting a wall or the hole
                while (x + dirs[i][0] >= 0 &&
                       x + dirs[i][0] < maze.length &&
                       y + dirs[i][1] >= 0 &&
                       y + dirs[i][1] < maze[0].length &&
                       maze[x + dirs[i][0]][y + dirs[i][1]] ==0) {
                    
                    x += dirs[i][0];
                    y += dirs[i][1];
                    dist += 1;
                    if (x == hole[0] && y == hole[1]) {
                        break;
                    }
                }
                if (maze[x][y]==0) {
                    pq.offer(new Point(x, y, dist, ds+dstr[i]));
                }
            }
        }
        return "impossible";
    }
 ```
 

### 30. Serialize and Deserialize Binary Tree lc297
 - [link](https://leetcode.com/problems/serialize-and-deserialize-binary-tree)
 - hard

### 31.1 Search a 2D Matrix lc74
 - [link](https://leetcode.com/problems/search-a-2d-matrix/)
 - medium
 - Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:
     - Integers in each row are sorted from left to right.
     - The first integer of each row is greater than the last integer of the previous row.
 - **Example:**
    ```python
    Input:
    matrix = [
      [1,   3,  5,  7],
      [10, 11, 16, 20],
      [23, 30, 34, 50]
    ]
    target = 3
    Output: true
    ```
 - binary search: [search2DMAtrix](https://github.com/tristaaa/lcproblems/blob/master/search2dmat.py)
 
### 31.2 Search a 2D Matrix II lc240
 - [link](https://leetcode.com/problems/search-a-2d-matrix-ii/)
 - medium
 - Write an efficient algorithm that searches for a value in an m x n matrix. This matrix has the following properties:
     - Integers in each row are sorted in ascending from left to right.
     - Integers in each column are sorted in ascending from top to bottom.
 - **Example:**
    ```python
    Input:
    matrix = [
      [1,   4,  7, 11, 15],
      [2,   5,  8, 12, 19],
      [3,   6,  9, 16, 22],
      [10, 13, 14, 17, 24],
      [18, 21, 23, 26, 30]
    ]
    target = 5
    Output: true
    ```
 - binary search: [search2DMAtrixII](https://github.com/tristaaa/lcproblems/blob/master/search2dmatii.py)
 

### 32.1 Critical Connections in a Network lc1192
 - [link](https://leetcode.com/problems/critical-connections-in-a-network/)
 - hard
 - There are n servers numbered from 0 to n-1 connected by undirected server-to-server connections forming a network where connections[i] = [a, b] represents a connection between servers a and b. Any server can reach any other server directly or indirectly through the network.
 - A critical connection is a connection that, if removed, will make some server unable to reach some other server.
 - Return all critical connections in the network in increasing order of node id.
 - **Example:**
    ```python
    Input: n = 5, connections = [[1, 2], [1, 3], [3, 4], [1, 4], [4, 5]]
    Output: [[1,2],[4,5]]
    ```
 - Tarjan's Algorithm (using dfs): [ctiticalConnections](https://github.com/tristaaa/lcproblems/blob/master/crtconnection.py)
 
### 32.2 Critical Routers in a Network
 - [link](https://leetcode.com/discuss/interview-question/436073/)
 - hard
 - You are given an undirected connected graph. 
 - An articulation point (or cut vertex) is defined as a vertex which, when removed along with associated edges, makes the graph disconnected (or more precisely, increases the number of connected components in the graph). 
 - The task is to find all articulation points in the given graph.
 - **Example:**
    ```python
    Input: 
        numNodes = 7
        numEdges = 7
        edges = [[0, 1], [0, 2], [1, 3], [2, 3], [2, 5], [5, 6], [3, 4]]
    Output: [2, 3, 5]
    ```
 - Tarjan's Algorithm (using dfs): [ctiticalRouters]
 ```java
    int time = 0; //global counter, used for the id of each vertex
    
    public List<Integer> criticalRouter(int numNodes, int numEdges, int[][] edges) {
        List<Integer>[] graph = new ArrayList[numNodes];
       
        for (int i = 0; i < numNodes; i++)
            graph[i]=new ArrayList();
        //build the graph
        for (int[] curr : edges) {
            graph[curr[0]].add(curr[1]);
            graph[curr[1]].add(curr[0]);
        }
        
        Set<Integer> ret = new HashSet<>();
        int[] low = new int[numNodes];
        int[] disc = new int[numNodes];
        Arrays.fill(disc, -1); // id of each vertex, mark the time when the vertex is discovered, -1 means undiscovered
        
        
        for (int i = 0; i < numNodes; i++) {
            if (disc[i] == -1)
                dfs(graph, i, -1, low, disc, ret);
        }
        
        return new ArrayList<Integer>(ret);
    }

    private void dfs(List<Integer>[] graph, int u, int parent, int[] low, int[] disc, Set<Integer> ret) {
        low[u] = disc[u] = ++time;
        
        // Count of children in DFS Tree 
        int children = 0; 
        
        // visit all the neighbors of node u
        for(int v: graph[u]) {
            if (v==parent) continue;
            else if (disc[v]==-1) {
                children++;
                dfs(graph, v, u, low, disc, ret);
                low[u] = Math.min(low[u], low[v]);
                
                //In DFS tree, a vertex u is articulation point if
                //1) u is root of DFS tree and it has at least two children.
                //or 2) u is not root of DFS tree and it has a child v such that 
                //no vertex in v's subtree has a back edge to one of the ancestors (in DFS tree) of u.
                if(parent==-1&&children>1 || parent!=-1&&low[v]>=disc[u])
                    ret.add(u);
            }
            else {
                //when node v is not the parent node of u in the DFS tree and has been visited
                //this occurs when edge(u,v) is a backwards edge 
                //(edges of G that don't belong to the DFS tree) in the DFS tree
                low[u] = Math.min(low[u], disc[v]);
            }                   
        }
    }
 ```

### 33. Search Suggestions System lc1268
 - [link](https://leetcode.com/problems/critical-connections-in-a-network/)
 - medium



lc93
lc00

[**Back To Top**](https://github.com/tristaaa/lcproblems#leetcode-problems)
